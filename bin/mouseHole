#!/usr/bin/env ruby
require 'optparse'
require 'ostruct'
require 'webrick/httpproxy'
require './lib/mouseHole'

options = OpenStruct.new
options.tidy = true
options.server = "webrick"
options.daemon = false

# locate ~/.mouseHole
homes = []
homes << [ENV['HOME'], File.join( ENV['HOME'], '.mouseHole' )] if ENV['HOME']
homes << [ENV['APPDATA'], File.join( ENV['APPDATA'], 'MouseHole' )] if ENV['APPDATA']
homes.each do |home_top, home_dir|
    next unless home_top
    if File.exists? home_top
        File.makedirs( home_dir )
        options.mouse_dir = home_dir
        break
    end
end

opts = OptionParser.new do |opts|
    opts.banner = "Usage: mouseHole [options] [ip or hostname] [port]"

    opts.separator ""
    opts.separator "Specific options:"

    opts.on("-d", "--directory DIRECTORY",
            "MouseHole directory (defaults to #{options.mouse_dir || 'None'})") do |d|
        options.mouse_dir = d
    end

    opts.on("-s", "--server SERVER_APP",
            "Web server to launch: webrick, lighttpd or apache2 (default is webrick)") do |s|
        options.server = s
    end

    opts.on("-D", "--[no-]daemon",  "Daemon mode") do |d|
        options.daemon = d
    end

    opts.on("-t", "--[no-]tidy",    "Use Tidy?") do |t|
        options.tidy = t
    end

    opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
        options.verbose = v
    end

    opts.separator ""
    opts.separator "Common options:"
  
    # No argument, shows at tail.  This will print an options summary.
    # Try it and see!
    opts.on_tail("-h", "--help", "Show this message") do
      puts opts
      exit
    end
  
    # Another typical switch to print the version.
    opts.on_tail("--version", "Show version") do
      puts MouseHole::VERSION
      exit
    end
end

opts.parse! ARGV
options.host = ARGV[0] || "127.0.0.1"
options.port = ARGV[1] || 37004

proxy_uri = nil
if env_http_proxy = ENV["HTTP_PROXY"]
    proxy_uri = URI.parse(env_http_proxy)
end
options.app_dir = Dir.pwd
if defined? RUBYSCRIPT2EXE_APPEXE
    options.app_dir = File.dirname( RUBYSCRIPT2EXE_APPEXE )
end
options.lib_dir = File.join( options.app_dir, 'lib' )
options.share_dir = File.join( options.app_dir, 'share' )
options.temp_dir = File.join( options.mouse_dir, 'temp' )
options.log_dir = File.join( options.mouse_dir, 'log' )
options.auto_marshal = %{Marshal.load( #{ Marshal.dump( options ).dump } )}
File.makedirs( options.temp_dir )
File.makedirs( options.log_dir )

case options.server
when "webrick"
    server = MouseHole::ProxyServer( WEBrick::HTTPProxyServer )::new( options,
        :BindAddress => options.host,
        :Port => options.port,
        :ProxyURI => proxy_uri,
        :ServerType => options.daemon ? WEBrick::Daemon : WEBrick::SimpleServer
    )
    server.mount( "/images", WEBrick::HTTPServlet::FileHandler, File.join( options.app_dir, 'images' ) )
    trap( :INT ) { server.shutdown }
    server.start
when "lighttpd"
    require 'erb'
    File.makedirs( File.join( options.temp_dir, 'lighttpd' ) )
    lighttpd_conf = File.join( options.temp_dir, 'lighttpd', 'lighttpd.conf' )
    File.open( lighttpd_conf, 'w' ) do |f|
        f << ERB.new( File.read( options.share_dir + '/lighttpd/lighttpd.conf' ) ).result
    end
    dispatch_cgi = File.join( options.temp_dir, 'lighttpd', 'dispatch.fcgi' )
    File.open( dispatch_cgi, 'w' ) do |f|
        f << ERB.new( File.read( options.share_dir + '/lighttpd/dispatch.fcgi' ) ).result
    end
    File.chmod( 0755, dispatch_cgi )
    lighttpd_path = `which lighttpd 2>/dev/null; whereis lighttpd`.
        scan( %r!\s/\S+/lighttpd\s! ).detect { |ctl| ctl.strip!
            `#{ctl} -v` =~ %r!lighttpd-1\.! }
    `#{ lighttpd_path } #{ options.daemon ? '' : '-D' } -f #{ lighttpd_conf }`
when "apache2"
    require 'erb'
    a2_dir = File.join( options.share_dir, 'apache2' )
    a2_temp = File.join( options.temp_dir, 'apache2' )
    a2_path = 
        `which apache2ctl 2>/dev/null; whereis apache2ctl; 
         which apachectl 2>/dev/null; whereis apachectl`.
            scan( %r!\s/\S+/apache2?ctl\s! ).detect { |ctl| ctl.strip!
                `#{ctl} -v` =~ %r!Apache/2\.! }
    a2 = `#{ a2_path } -V`.scan( /-D\s*(\w+)\s*=\s*"(.+)"/ ).
            inject({}) { |hsh,(k,v)| hsh[k] = v; hsh }
    a2_conf = File.expand_path( a2['SERVER_CONFIG_FILE'], a2['HTTPD_ROOT'] )
    File.foreach( a2_conf ) do |line|
        case line
        when /^\s*ServerRoot\s+("(.+?)"|(\S+))/
            options.server_root = ($2 || $1).strip
        when /^\s*LoadModule\s+(\w+)\s+(\S+)/
            mod_name, mod_path = $1, $2
            options.modules ||= Hash.new do |hsh,k|
                `find #{ options.server_root } -name "mod_#{ k }.*"`.
                    gsub( /^#{ options.server_root }\/?/, '' )
            end
            options.modules[mod_name.gsub( /_module$/, '' )] = mod_path
        end
    end

    files = {}
    Dir["#{a2_dir}/**/*"].each do |from_file|
        next if File.directory? from_file
        to_file = from_file.gsub( a2_dir, a2_temp ).
                            gsub( /\/dot\./, '/.' )
        unless File.exists? File.dirname( to_file )
            File.makedirs( File.dirname( to_file ) )
        end
        File.open( to_file, 'w' ) do |f|
            f << ERB.new( File.read( from_file ) ).result
        end
        files[to_file.gsub("#{a2_temp}/", '')] = to_file
    end
    File.chmod( 0755, files['htdocs/index.rbx'] )
    `#{ a2_path } -f #{ files['httpd.conf'] }`
else
    abort "** Server `#{ options.server }' not supported."
end
